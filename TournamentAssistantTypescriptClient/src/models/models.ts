// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "models.proto" (package "proto.models", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Channel } from './discord.js';
/**
 * @generated from protobuf message proto.models.Characteristic
 */
export interface Characteristic {
    /**
     * @generated from protobuf field: string serialized_name = 1;
     */
    serializedName: string;
    /**
     * @generated from protobuf field: repeated int32 difficulties = 2;
     */
    difficulties: number[];
}
/**
 * @generated from protobuf message proto.models.Beatmap
 */
export interface Beatmap {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string level_id = 2;
     */
    levelId: string;
    /**
     * @generated from protobuf field: proto.models.Characteristic characteristic = 3;
     */
    characteristic?: Characteristic;
    /**
     * @generated from protobuf field: int32 difficulty = 4;
     */
    difficulty: number;
}
/**
 * @generated from protobuf message proto.models.GameplayModifiers
 */
export interface GameplayModifiers {
    /**
     * @generated from protobuf field: proto.models.GameplayModifiers.GameOptions options = 1;
     */
    options: GameplayModifiers_GameOptions;
}
/**
 * @generated from protobuf enum proto.models.GameplayModifiers.GameOptions
 */
export enum GameplayModifiers_GameOptions {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * Negative modifiers
     *
     * @generated from protobuf enum value: NoFail = 1;
     */
    NoFail = 1,
    /**
     * @generated from protobuf enum value: NoBombs = 2;
     */
    NoBombs = 2,
    /**
     * @generated from protobuf enum value: NoArrows = 4;
     */
    NoArrows = 4,
    /**
     * @generated from protobuf enum value: NoObstacles = 8;
     */
    NoObstacles = 8,
    /**
     * @generated from protobuf enum value: SlowSong = 16;
     */
    SlowSong = 16,
    /**
     * Positive Modifiers
     *
     * @generated from protobuf enum value: InstaFail = 32;
     */
    InstaFail = 32,
    /**
     * @generated from protobuf enum value: FailOnClash = 64;
     */
    FailOnClash = 64,
    /**
     * @generated from protobuf enum value: BatteryEnergy = 128;
     */
    BatteryEnergy = 128,
    /**
     * @generated from protobuf enum value: FastNotes = 256;
     */
    FastNotes = 256,
    /**
     * @generated from protobuf enum value: FastSong = 512;
     */
    FastSong = 512,
    /**
     * @generated from protobuf enum value: DisappearingArrows = 1024;
     */
    DisappearingArrows = 1024,
    /**
     * @generated from protobuf enum value: GhostNotes = 2048;
     */
    GhostNotes = 2048,
    /**
     * 1.12.2 Additions
     *
     * @generated from protobuf enum value: DemoNoFail = 4096;
     */
    DemoNoFail = 4096,
    /**
     * @generated from protobuf enum value: DemoNoObstacles = 8192;
     */
    DemoNoObstacles = 8192,
    /**
     * @generated from protobuf enum value: StrictAngles = 16384;
     */
    StrictAngles = 16384,
    /**
     * 1.13.4 Additions
     *
     * @generated from protobuf enum value: ProMode = 32768;
     */
    ProMode = 32768,
    /**
     * @generated from protobuf enum value: ZenMode = 65536;
     */
    ZenMode = 65536,
    /**
     * @generated from protobuf enum value: SmallCubes = 131072;
     */
    SmallCubes = 131072,
    /**
     * @generated from protobuf enum value: SuperFastSong = 262144;
     */
    SuperFastSong = 262144
}
/**
 * @generated from protobuf message proto.models.PlayerSpecificSettings
 */
export interface PlayerSpecificSettings {
    /**
     * @generated from protobuf field: float player_height = 1;
     */
    playerHeight: number;
    /**
     * @generated from protobuf field: float sfx_volume = 2;
     */
    sfxVolume: number;
    /**
     * @generated from protobuf field: float saber_trail_intensity = 3;
     */
    saberTrailIntensity: number;
    /**
     * @generated from protobuf field: float note_jump_start_beat_offset = 4;
     */
    noteJumpStartBeatOffset: number;
    /**
     * @generated from protobuf field: float note_jump_fixed_duration = 5;
     */
    noteJumpFixedDuration: number;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.PlayerOptions options = 6;
     */
    options: PlayerSpecificSettings_PlayerOptions;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings = 7;
     */
    noteJumpDurationTypeSettings: PlayerSpecificSettings_NoteJumpDurationTypeSettings;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type = 8;
     */
    arcVisibilityType: PlayerSpecificSettings_ArcVisibilityType;
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.PlayerOptions
 */
export enum PlayerSpecificSettings_PlayerOptions {
    /**
     * @generated from protobuf enum value: NoPlayerOptions = 0;
     */
    NoPlayerOptions = 0,
    /**
     * @generated from protobuf enum value: LeftHanded = 1;
     */
    LeftHanded = 1,
    /**
     * @generated from protobuf enum value: StaticLights = 2;
     */
    StaticLights = 2,
    /**
     * @generated from protobuf enum value: NoHud = 4;
     */
    NoHud = 4,
    /**
     * @generated from protobuf enum value: AdvancedHud = 8;
     */
    AdvancedHud = 8,
    /**
     * @generated from protobuf enum value: ReduceDebris = 16;
     */
    ReduceDebris = 16,
    /**
     * @generated from protobuf enum value: AutoPlayerHeight = 32;
     */
    AutoPlayerHeight = 32,
    /**
     * @generated from protobuf enum value: NoFailEffects = 64;
     */
    NoFailEffects = 64,
    /**
     * @generated from protobuf enum value: AutoRestart = 128;
     */
    AutoRestart = 128,
    /**
     * @generated from protobuf enum value: HideNoteSpawnEffect = 256;
     */
    HideNoteSpawnEffect = 256,
    /**
     * @generated from protobuf enum value: AdaptiveSfx = 512;
     */
    AdaptiveSfx = 512,
    /**
     * @generated from protobuf enum value: ArcsHapticFeedback = 1024;
     */
    ArcsHapticFeedback = 1024
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings
 */
export enum PlayerSpecificSettings_NoteJumpDurationTypeSettings {
    /**
     * @generated from protobuf enum value: Dynamic = 0;
     */
    Dynamic = 0,
    /**
     * @generated from protobuf enum value: Static = 1;
     */
    Static = 1
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.ArcVisibilityType
 */
export enum PlayerSpecificSettings_ArcVisibilityType {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Low = 1;
     */
    Low = 1,
    /**
     * @generated from protobuf enum value: Standard = 2;
     */
    Standard = 2,
    /**
     * @generated from protobuf enum value: High = 3;
     */
    High = 3
}
/**
 * @generated from protobuf message proto.models.GameplayParameters
 */
export interface GameplayParameters {
    /**
     * @generated from protobuf field: proto.models.Beatmap beatmap = 1;
     */
    beatmap?: Beatmap;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings player_settings = 2;
     */
    playerSettings?: PlayerSpecificSettings;
    /**
     * @generated from protobuf field: proto.models.GameplayModifiers gameplay_modifiers = 3;
     */
    gameplayModifiers?: GameplayModifiers;
    /**
     * @generated from protobuf field: int32 attempts = 4;
     */
    attempts: number; // Qualifiers only
    /**
     * @generated from protobuf field: bool show_scoreboard = 5;
     */
    showScoreboard: boolean;
    /**
     * @generated from protobuf field: bool disable_pause = 6;
     */
    disablePause: boolean;
    /**
     * @generated from protobuf field: bool disable_fail = 7;
     */
    disableFail: boolean;
    /**
     * @generated from protobuf field: bool disable_scoresaber_submission = 8;
     */
    disableScoresaberSubmission: boolean;
    /**
     * @generated from protobuf field: bool disable_custom_notes_on_stream = 9;
     */
    disableCustomNotesOnStream: boolean;
    /**
     * @generated from protobuf field: bool use_sync = 10;
     */
    useSync: boolean;
}
/**
 * @generated from protobuf message proto.models.Map
 */
export interface Map {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: proto.models.GameplayParameters gameplay_parameters = 2;
     */
    gameplayParameters?: GameplayParameters;
}
/**
 * @generated from protobuf message proto.models.User
 */
export interface User {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string platform_id = 3;
     */
    platformId: string;
    /**
     * @generated from protobuf field: proto.models.User.ClientTypes client_type = 4;
     */
    clientType: User_ClientTypes;
    /**
     * @generated from protobuf field: string team_id = 5;
     */
    teamId: string;
    /**
     * @generated from protobuf field: proto.models.User.PlayStates play_state = 6;
     */
    playState: User_PlayStates;
    /**
     * @generated from protobuf field: proto.models.User.DownloadStates download_state = 7;
     */
    downloadState: User_DownloadStates;
    /**
     * @generated from protobuf field: repeated string mod_list = 8;
     */
    modList: string[];
    /**
     * @generated from protobuf field: proto.models.User.Point stream_screen_coordinates = 9;
     */
    streamScreenCoordinates?: User_Point;
    /**
     * @generated from protobuf field: int64 stream_delay_ms = 10;
     */
    streamDelayMs: bigint;
    /**
     * @generated from protobuf field: int64 stream_sync_start_ms = 11;
     */
    streamSyncStartMs: bigint;
    /**
     * @generated from protobuf field: proto.models.User.DiscordInfo discord_info = 12;
     */
    discordInfo?: User_DiscordInfo;
    /**
     * @generated from protobuf field: bytes user_image = 13;
     */
    userImage: Uint8Array;
    /**
     * @generated from protobuf field: proto.models.Permissions permissions = 14;
     */
    permissions: Permissions;
}
/**
 * @generated from protobuf message proto.models.User.DiscordInfo
 */
export interface User_DiscordInfo {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * @generated from protobuf field: string avatar_url = 3;
     */
    avatarUrl: string;
}
/**
 * @generated from protobuf message proto.models.User.Point
 */
export interface User_Point {
    /**
     * @generated from protobuf field: int32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2;
     */
    y: number;
}
/**
 * @generated from protobuf enum proto.models.User.PlayStates
 */
export enum User_PlayStates {
    /**
     * @generated from protobuf enum value: InMenu = 0;
     */
    InMenu = 0,
    /**
     * @generated from protobuf enum value: WaitingForCoordinator = 1;
     */
    WaitingForCoordinator = 1,
    /**
     * @generated from protobuf enum value: InGame = 2;
     */
    InGame = 2
}
/**
 * @generated from protobuf enum proto.models.User.DownloadStates
 */
export enum User_DownloadStates {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Downloading = 1;
     */
    Downloading = 1,
    /**
     * @generated from protobuf enum value: Downloaded = 2;
     */
    Downloaded = 2,
    /**
     * @generated from protobuf enum value: DownloadError = 3;
     */
    DownloadError = 3
}
/**
 * @generated from protobuf enum proto.models.User.ClientTypes
 */
export enum User_ClientTypes {
    /**
     * @generated from protobuf enum value: Player = 0;
     */
    Player = 0,
    /**
     * @generated from protobuf enum value: WebsocketConnection = 1;
     */
    WebsocketConnection = 1
}
/**
 * @generated from protobuf message proto.models.Match
 */
export interface Match {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: repeated string associated_users = 2;
     */
    associatedUsers: string[];
    /**
     * @generated from protobuf field: string leader = 3;
     */
    leader: string;
    /**
     * @generated from protobuf field: proto.models.Map selected_map = 4;
     */
    selectedMap?: Map;
}
/**
 * @generated from protobuf message proto.models.QualifierEvent
 */
export interface QualifierEvent {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes image = 3;
     */
    image: Uint8Array;
    /**
     * @generated from protobuf field: proto.discord.Channel info_channel = 4;
     */
    infoChannel?: Channel;
    /**
     * @generated from protobuf field: repeated proto.models.Map qualifier_maps = 5;
     */
    qualifierMaps: Map[];
    /**
     * @generated from protobuf field: proto.models.QualifierEvent.EventSettings flags = 6;
     */
    flags: QualifierEvent_EventSettings;
    /**
     * @generated from protobuf field: proto.models.QualifierEvent.LeaderboardSort sort = 7;
     */
    sort: QualifierEvent_LeaderboardSort;
}
/**
 * @generated from protobuf enum proto.models.QualifierEvent.EventSettings
 */
export enum QualifierEvent_EventSettings {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: HideScoresFromPlayers = 1;
     */
    HideScoresFromPlayers = 1,
    /**
     * @generated from protobuf enum value: DisableScoresaberSubmission = 2;
     */
    DisableScoresaberSubmission = 2,
    /**
     * @generated from protobuf enum value: EnableDiscordScoreFeed = 4;
     */
    EnableDiscordScoreFeed = 4,
    /**
     * @generated from protobuf enum value: EnableDiscordLeaderboard = 8;
     */
    EnableDiscordLeaderboard = 8
}
/**
 * @generated from protobuf enum proto.models.QualifierEvent.LeaderboardSort
 */
export enum QualifierEvent_LeaderboardSort {
    /**
     * @generated from protobuf enum value: ModifiedScore = 0;
     */
    ModifiedScore = 0,
    /**
     * @generated from protobuf enum value: ModifiedScoreAscending = 1;
     */
    ModifiedScoreAscending = 1,
    /**
     * @generated from protobuf enum value: NotesMissed = 2;
     */
    NotesMissed = 2,
    /**
     * @generated from protobuf enum value: NotesMissedAscending = 3;
     */
    NotesMissedAscending = 3,
    /**
     * @generated from protobuf enum value: BadCuts = 4;
     */
    BadCuts = 4,
    /**
     * @generated from protobuf enum value: BadCutsAscending = 5;
     */
    BadCutsAscending = 5,
    /**
     * @generated from protobuf enum value: MaxCombo = 6;
     */
    MaxCombo = 6,
    /**
     * @generated from protobuf enum value: MaxComboAscending = 7;
     */
    MaxComboAscending = 7,
    /**
     * @generated from protobuf enum value: GoodCuts = 8;
     */
    GoodCuts = 8,
    /**
     * @generated from protobuf enum value: GoodCutsAscending = 9;
     */
    GoodCutsAscending = 9
}
/**
 * @generated from protobuf message proto.models.CoreServer
 */
export interface CoreServer {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: int32 websocket_port = 4;
     */
    websocketPort: number;
}
/**
 * @generated from protobuf message proto.models.Tournament
 */
export interface Tournament {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: proto.models.Tournament.TournamentSettings settings = 2;
     */
    settings?: Tournament_TournamentSettings;
    /**
     * @generated from protobuf field: repeated proto.models.User users = 3;
     */
    users: User[];
    /**
     * @generated from protobuf field: repeated proto.models.Match matches = 4;
     */
    matches: Match[];
    /**
     * @generated from protobuf field: repeated proto.models.QualifierEvent qualifiers = 5;
     */
    qualifiers: QualifierEvent[];
    /**
     * @generated from protobuf field: proto.models.CoreServer server = 6;
     */
    server?: CoreServer;
}
/**
 * @generated from protobuf message proto.models.Tournament.TournamentSettings
 */
export interface Tournament_TournamentSettings {
    /**
     * @generated from protobuf field: string tournament_name = 1;
     */
    tournamentName: string;
    /**
     * @generated from protobuf field: bytes tournament_image = 2;
     */
    tournamentImage: Uint8Array;
    /**
     * @generated from protobuf field: bool enable_teams = 3;
     */
    enableTeams: boolean;
    /**
     * @generated from protobuf field: bool enable_pools = 4;
     */
    enablePools: boolean;
    /**
     * @generated from protobuf field: repeated proto.models.Tournament.TournamentSettings.Team teams = 5;
     */
    teams: Tournament_TournamentSettings_Team[];
    /**
     * @generated from protobuf field: int32 score_update_frequency = 6;
     */
    scoreUpdateFrequency: number;
    /**
     * @generated from protobuf field: repeated string banned_mods = 7;
     */
    bannedMods: string[];
    /**
     * @generated from protobuf field: repeated proto.models.Tournament.TournamentSettings.Pool pools = 8;
     */
    pools: Tournament_TournamentSettings_Pool[];
    /**
     * @generated from protobuf field: bool show_tournament_button = 9;
     */
    showTournamentButton: boolean;
    /**
     * @generated from protobuf field: bool show_qualifier_button = 10;
     */
    showQualifierButton: boolean;
    /**
     * @generated from protobuf field: bool allow_unauthorized_view = 11;
     */
    allowUnauthorizedView: boolean;
}
/**
 * @generated from protobuf message proto.models.Tournament.TournamentSettings.Pool
 */
export interface Tournament_TournamentSettings_Pool {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes image = 3;
     */
    image: Uint8Array;
    /**
     * @generated from protobuf field: repeated proto.models.Map maps = 4;
     */
    maps: Map[];
}
/**
 * @generated from protobuf message proto.models.Tournament.TournamentSettings.Team
 */
export interface Tournament_TournamentSettings_Team {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes image = 3;
     */
    image: Uint8Array;
}
/**
 * @generated from protobuf message proto.models.State
 */
export interface State {
    /**
     * @generated from protobuf field: repeated proto.models.Tournament tournaments = 1;
     */
    tournaments: Tournament[];
    /**
     * @generated from protobuf field: repeated proto.models.CoreServer known_servers = 2;
     */
    knownServers: CoreServer[];
}
/**
 * @generated from protobuf message proto.models.ModalOption
 */
export interface ModalOption {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto.models.LeaderboardEntry
 */
export interface LeaderboardEntry {
    /**
     * @generated from protobuf field: string event_id = 1;
     */
    eventId: string;
    /**
     * @generated from protobuf field: string map_id = 2;
     */
    mapId: string;
    /**
     * @generated from protobuf field: string platform_id = 3;
     */
    platformId: string;
    /**
     * @generated from protobuf field: string username = 4;
     */
    username: string;
    /**
     * @generated from protobuf field: int32 multiplied_score = 5;
     */
    multipliedScore: number;
    /**
     * @generated from protobuf field: int32 modified_score = 6;
     */
    modifiedScore: number;
    /**
     * @generated from protobuf field: int32 max_possible_score = 7;
     */
    maxPossibleScore: number;
    /**
     * @generated from protobuf field: double accuracy = 8;
     */
    accuracy: number;
    /**
     * @generated from protobuf field: int32 notes_missed = 9;
     */
    notesMissed: number;
    /**
     * @generated from protobuf field: int32 bad_cuts = 10;
     */
    badCuts: number;
    /**
     * @generated from protobuf field: int32 good_cuts = 11;
     */
    goodCuts: number;
    /**
     * @generated from protobuf field: int32 max_combo = 12;
     */
    maxCombo: number;
    /**
     * @generated from protobuf field: bool full_combo = 13;
     */
    fullCombo: boolean;
    /**
     * @generated from protobuf field: bool is_placeholder = 14;
     */
    isPlaceholder: boolean;
    /**
     * @generated from protobuf field: string color = 15;
     */
    color: string;
}
/**
 * @generated from protobuf message proto.models.RealtimeScore
 */
export interface RealtimeScore {
    /**
     * @generated from protobuf field: string user_guid = 1;
     */
    userGuid: string;
    /**
     * @generated from protobuf field: int32 score = 2;
     */
    score: number;
    /**
     * @generated from protobuf field: int32 score_with_modifiers = 3;
     */
    scoreWithModifiers: number;
    /**
     * @generated from protobuf field: int32 max_score = 4;
     */
    maxScore: number;
    /**
     * @generated from protobuf field: int32 max_score_with_modifiers = 5;
     */
    maxScoreWithModifiers: number;
    /**
     * @generated from protobuf field: int32 combo = 6;
     */
    combo: number;
    /**
     * @generated from protobuf field: float player_health = 7;
     */
    playerHealth: number;
    /**
     * @generated from protobuf field: float accuracy = 8;
     */
    accuracy: number;
    /**
     * @generated from protobuf field: float song_position = 9;
     */
    songPosition: number;
    /**
     * @generated from protobuf field: int32 notes_missed = 10;
     */
    notesMissed: number;
    /**
     * @generated from protobuf field: int32 bad_cuts = 11;
     */
    badCuts: number;
    /**
     * @generated from protobuf field: int32 bomb_hits = 12;
     */
    bombHits: number;
    /**
     * @generated from protobuf field: int32 wall_hits = 13;
     */
    wallHits: number;
    /**
     * @generated from protobuf field: int32 max_combo = 14;
     */
    maxCombo: number;
    /**
     * @generated from protobuf field: proto.models.ScoreTrackerHand left_hand = 15;
     */
    leftHand?: ScoreTrackerHand;
    /**
     * @generated from protobuf field: proto.models.ScoreTrackerHand right_hand = 16;
     */
    rightHand?: ScoreTrackerHand;
}
/**
 * @generated from protobuf message proto.models.ScoreTrackerHand
 */
export interface ScoreTrackerHand {
    /**
     * @generated from protobuf field: int32 hit = 1;
     */
    hit: number;
    /**
     * @generated from protobuf field: int32 miss = 2;
     */
    miss: number;
    /**
     * @generated from protobuf field: int32 bad_cut = 3;
     */
    badCut: number;
    /**
     * @generated from protobuf field: repeated float avg_cut = 4;
     */
    avgCut: number[];
}
/**
 * @generated from protobuf enum proto.models.Permissions
 */
export enum Permissions {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: View = 1;
     */
    View = 1,
    /**
     * @generated from protobuf enum value: Admin = 2;
     */
    Admin = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Characteristic$Type extends MessageType<Characteristic> {
    constructor() {
        super("proto.models.Characteristic", [
            { no: 1, name: "serialized_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "difficulties", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Characteristic>): Characteristic {
        const message = { serializedName: "", difficulties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Characteristic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Characteristic): Characteristic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serialized_name */ 1:
                    message.serializedName = reader.string();
                    break;
                case /* repeated int32 difficulties */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.difficulties.push(reader.int32());
                    else
                        message.difficulties.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Characteristic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serialized_name = 1; */
        if (message.serializedName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serializedName);
        /* repeated int32 difficulties = 2; */
        if (message.difficulties.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.difficulties.length; i++)
                writer.int32(message.difficulties[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Characteristic
 */
export const Characteristic = new Characteristic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Beatmap$Type extends MessageType<Beatmap> {
    constructor() {
        super("proto.models.Beatmap", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "characteristic", kind: "message", T: () => Characteristic },
            { no: 4, name: "difficulty", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Beatmap>): Beatmap {
        const message = { name: "", levelId: "", difficulty: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Beatmap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Beatmap): Beatmap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string level_id */ 2:
                    message.levelId = reader.string();
                    break;
                case /* proto.models.Characteristic characteristic */ 3:
                    message.characteristic = Characteristic.internalBinaryRead(reader, reader.uint32(), options, message.characteristic);
                    break;
                case /* int32 difficulty */ 4:
                    message.difficulty = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Beatmap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string level_id = 2; */
        if (message.levelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.levelId);
        /* proto.models.Characteristic characteristic = 3; */
        if (message.characteristic)
            Characteristic.internalBinaryWrite(message.characteristic, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 difficulty = 4; */
        if (message.difficulty !== 0)
            writer.tag(4, WireType.Varint).int32(message.difficulty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Beatmap
 */
export const Beatmap = new Beatmap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameplayModifiers$Type extends MessageType<GameplayModifiers> {
    constructor() {
        super("proto.models.GameplayModifiers", [
            { no: 1, name: "options", kind: "enum", T: () => ["proto.models.GameplayModifiers.GameOptions", GameplayModifiers_GameOptions] }
        ]);
    }
    create(value?: PartialMessage<GameplayModifiers>): GameplayModifiers {
        const message = { options: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GameplayModifiers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameplayModifiers): GameplayModifiers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.models.GameplayModifiers.GameOptions options */ 1:
                    message.options = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameplayModifiers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.models.GameplayModifiers.GameOptions options = 1; */
        if (message.options !== 0)
            writer.tag(1, WireType.Varint).int32(message.options);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.GameplayModifiers
 */
export const GameplayModifiers = new GameplayModifiers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerSpecificSettings$Type extends MessageType<PlayerSpecificSettings> {
    constructor() {
        super("proto.models.PlayerSpecificSettings", [
            { no: 1, name: "player_height", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "sfx_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "saber_trail_intensity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "note_jump_start_beat_offset", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "note_jump_fixed_duration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "options", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.PlayerOptions", PlayerSpecificSettings_PlayerOptions] },
            { no: 7, name: "note_jump_duration_type_settings", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings", PlayerSpecificSettings_NoteJumpDurationTypeSettings] },
            { no: 8, name: "arc_visibility_type", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.ArcVisibilityType", PlayerSpecificSettings_ArcVisibilityType] }
        ]);
    }
    create(value?: PartialMessage<PlayerSpecificSettings>): PlayerSpecificSettings {
        const message = { playerHeight: 0, sfxVolume: 0, saberTrailIntensity: 0, noteJumpStartBeatOffset: 0, noteJumpFixedDuration: 0, options: 0, noteJumpDurationTypeSettings: 0, arcVisibilityType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerSpecificSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerSpecificSettings): PlayerSpecificSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float player_height */ 1:
                    message.playerHeight = reader.float();
                    break;
                case /* float sfx_volume */ 2:
                    message.sfxVolume = reader.float();
                    break;
                case /* float saber_trail_intensity */ 3:
                    message.saberTrailIntensity = reader.float();
                    break;
                case /* float note_jump_start_beat_offset */ 4:
                    message.noteJumpStartBeatOffset = reader.float();
                    break;
                case /* float note_jump_fixed_duration */ 5:
                    message.noteJumpFixedDuration = reader.float();
                    break;
                case /* proto.models.PlayerSpecificSettings.PlayerOptions options */ 6:
                    message.options = reader.int32();
                    break;
                case /* proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings */ 7:
                    message.noteJumpDurationTypeSettings = reader.int32();
                    break;
                case /* proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type */ 8:
                    message.arcVisibilityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerSpecificSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float player_height = 1; */
        if (message.playerHeight !== 0)
            writer.tag(1, WireType.Bit32).float(message.playerHeight);
        /* float sfx_volume = 2; */
        if (message.sfxVolume !== 0)
            writer.tag(2, WireType.Bit32).float(message.sfxVolume);
        /* float saber_trail_intensity = 3; */
        if (message.saberTrailIntensity !== 0)
            writer.tag(3, WireType.Bit32).float(message.saberTrailIntensity);
        /* float note_jump_start_beat_offset = 4; */
        if (message.noteJumpStartBeatOffset !== 0)
            writer.tag(4, WireType.Bit32).float(message.noteJumpStartBeatOffset);
        /* float note_jump_fixed_duration = 5; */
        if (message.noteJumpFixedDuration !== 0)
            writer.tag(5, WireType.Bit32).float(message.noteJumpFixedDuration);
        /* proto.models.PlayerSpecificSettings.PlayerOptions options = 6; */
        if (message.options !== 0)
            writer.tag(6, WireType.Varint).int32(message.options);
        /* proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings = 7; */
        if (message.noteJumpDurationTypeSettings !== 0)
            writer.tag(7, WireType.Varint).int32(message.noteJumpDurationTypeSettings);
        /* proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type = 8; */
        if (message.arcVisibilityType !== 0)
            writer.tag(8, WireType.Varint).int32(message.arcVisibilityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.PlayerSpecificSettings
 */
export const PlayerSpecificSettings = new PlayerSpecificSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameplayParameters$Type extends MessageType<GameplayParameters> {
    constructor() {
        super("proto.models.GameplayParameters", [
            { no: 1, name: "beatmap", kind: "message", T: () => Beatmap },
            { no: 2, name: "player_settings", kind: "message", T: () => PlayerSpecificSettings },
            { no: 3, name: "gameplay_modifiers", kind: "message", T: () => GameplayModifiers },
            { no: 4, name: "attempts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "show_scoreboard", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "disable_pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disable_fail", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "disable_scoresaber_submission", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "disable_custom_notes_on_stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "use_sync", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GameplayParameters>): GameplayParameters {
        const message = { attempts: 0, showScoreboard: false, disablePause: false, disableFail: false, disableScoresaberSubmission: false, disableCustomNotesOnStream: false, useSync: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GameplayParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameplayParameters): GameplayParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.models.Beatmap beatmap */ 1:
                    message.beatmap = Beatmap.internalBinaryRead(reader, reader.uint32(), options, message.beatmap);
                    break;
                case /* proto.models.PlayerSpecificSettings player_settings */ 2:
                    message.playerSettings = PlayerSpecificSettings.internalBinaryRead(reader, reader.uint32(), options, message.playerSettings);
                    break;
                case /* proto.models.GameplayModifiers gameplay_modifiers */ 3:
                    message.gameplayModifiers = GameplayModifiers.internalBinaryRead(reader, reader.uint32(), options, message.gameplayModifiers);
                    break;
                case /* int32 attempts */ 4:
                    message.attempts = reader.int32();
                    break;
                case /* bool show_scoreboard */ 5:
                    message.showScoreboard = reader.bool();
                    break;
                case /* bool disable_pause */ 6:
                    message.disablePause = reader.bool();
                    break;
                case /* bool disable_fail */ 7:
                    message.disableFail = reader.bool();
                    break;
                case /* bool disable_scoresaber_submission */ 8:
                    message.disableScoresaberSubmission = reader.bool();
                    break;
                case /* bool disable_custom_notes_on_stream */ 9:
                    message.disableCustomNotesOnStream = reader.bool();
                    break;
                case /* bool use_sync */ 10:
                    message.useSync = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameplayParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.models.Beatmap beatmap = 1; */
        if (message.beatmap)
            Beatmap.internalBinaryWrite(message.beatmap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.PlayerSpecificSettings player_settings = 2; */
        if (message.playerSettings)
            PlayerSpecificSettings.internalBinaryWrite(message.playerSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.GameplayModifiers gameplay_modifiers = 3; */
        if (message.gameplayModifiers)
            GameplayModifiers.internalBinaryWrite(message.gameplayModifiers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 attempts = 4; */
        if (message.attempts !== 0)
            writer.tag(4, WireType.Varint).int32(message.attempts);
        /* bool show_scoreboard = 5; */
        if (message.showScoreboard !== false)
            writer.tag(5, WireType.Varint).bool(message.showScoreboard);
        /* bool disable_pause = 6; */
        if (message.disablePause !== false)
            writer.tag(6, WireType.Varint).bool(message.disablePause);
        /* bool disable_fail = 7; */
        if (message.disableFail !== false)
            writer.tag(7, WireType.Varint).bool(message.disableFail);
        /* bool disable_scoresaber_submission = 8; */
        if (message.disableScoresaberSubmission !== false)
            writer.tag(8, WireType.Varint).bool(message.disableScoresaberSubmission);
        /* bool disable_custom_notes_on_stream = 9; */
        if (message.disableCustomNotesOnStream !== false)
            writer.tag(9, WireType.Varint).bool(message.disableCustomNotesOnStream);
        /* bool use_sync = 10; */
        if (message.useSync !== false)
            writer.tag(10, WireType.Varint).bool(message.useSync);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.GameplayParameters
 */
export const GameplayParameters = new GameplayParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Map$Type extends MessageType<Map> {
    constructor() {
        super("proto.models.Map", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gameplay_parameters", kind: "message", T: () => GameplayParameters }
        ]);
    }
    create(value?: PartialMessage<Map>): Map {
        const message = { guid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Map>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Map): Map {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* proto.models.GameplayParameters gameplay_parameters */ 2:
                    message.gameplayParameters = GameplayParameters.internalBinaryRead(reader, reader.uint32(), options, message.gameplayParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Map, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* proto.models.GameplayParameters gameplay_parameters = 2; */
        if (message.gameplayParameters)
            GameplayParameters.internalBinaryWrite(message.gameplayParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Map
 */
export const Map = new Map$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("proto.models.User", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "client_type", kind: "enum", T: () => ["proto.models.User.ClientTypes", User_ClientTypes] },
            { no: 5, name: "team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "play_state", kind: "enum", T: () => ["proto.models.User.PlayStates", User_PlayStates] },
            { no: 7, name: "download_state", kind: "enum", T: () => ["proto.models.User.DownloadStates", User_DownloadStates] },
            { no: 8, name: "mod_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "stream_screen_coordinates", kind: "message", T: () => User_Point },
            { no: 10, name: "stream_delay_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "stream_sync_start_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "discord_info", kind: "message", T: () => User_DiscordInfo },
            { no: 13, name: "user_image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 14, name: "permissions", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { guid: "", name: "", platformId: "", clientType: 0, teamId: "", playState: 0, downloadState: 0, modList: [], streamDelayMs: 0n, streamSyncStartMs: 0n, userImage: new Uint8Array(0), permissions: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string platform_id */ 3:
                    message.platformId = reader.string();
                    break;
                case /* proto.models.User.ClientTypes client_type */ 4:
                    message.clientType = reader.int32();
                    break;
                case /* string team_id */ 5:
                    message.teamId = reader.string();
                    break;
                case /* proto.models.User.PlayStates play_state */ 6:
                    message.playState = reader.int32();
                    break;
                case /* proto.models.User.DownloadStates download_state */ 7:
                    message.downloadState = reader.int32();
                    break;
                case /* repeated string mod_list */ 8:
                    message.modList.push(reader.string());
                    break;
                case /* proto.models.User.Point stream_screen_coordinates */ 9:
                    message.streamScreenCoordinates = User_Point.internalBinaryRead(reader, reader.uint32(), options, message.streamScreenCoordinates);
                    break;
                case /* int64 stream_delay_ms */ 10:
                    message.streamDelayMs = reader.int64().toBigInt();
                    break;
                case /* int64 stream_sync_start_ms */ 11:
                    message.streamSyncStartMs = reader.int64().toBigInt();
                    break;
                case /* proto.models.User.DiscordInfo discord_info */ 12:
                    message.discordInfo = User_DiscordInfo.internalBinaryRead(reader, reader.uint32(), options, message.discordInfo);
                    break;
                case /* bytes user_image */ 13:
                    message.userImage = reader.bytes();
                    break;
                case /* proto.models.Permissions permissions */ 14:
                    message.permissions = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string platform_id = 3; */
        if (message.platformId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.platformId);
        /* proto.models.User.ClientTypes client_type = 4; */
        if (message.clientType !== 0)
            writer.tag(4, WireType.Varint).int32(message.clientType);
        /* string team_id = 5; */
        if (message.teamId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.teamId);
        /* proto.models.User.PlayStates play_state = 6; */
        if (message.playState !== 0)
            writer.tag(6, WireType.Varint).int32(message.playState);
        /* proto.models.User.DownloadStates download_state = 7; */
        if (message.downloadState !== 0)
            writer.tag(7, WireType.Varint).int32(message.downloadState);
        /* repeated string mod_list = 8; */
        for (let i = 0; i < message.modList.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.modList[i]);
        /* proto.models.User.Point stream_screen_coordinates = 9; */
        if (message.streamScreenCoordinates)
            User_Point.internalBinaryWrite(message.streamScreenCoordinates, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 stream_delay_ms = 10; */
        if (message.streamDelayMs !== 0n)
            writer.tag(10, WireType.Varint).int64(message.streamDelayMs);
        /* int64 stream_sync_start_ms = 11; */
        if (message.streamSyncStartMs !== 0n)
            writer.tag(11, WireType.Varint).int64(message.streamSyncStartMs);
        /* proto.models.User.DiscordInfo discord_info = 12; */
        if (message.discordInfo)
            User_DiscordInfo.internalBinaryWrite(message.discordInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bytes user_image = 13; */
        if (message.userImage.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.userImage);
        /* proto.models.Permissions permissions = 14; */
        if (message.permissions !== 0)
            writer.tag(14, WireType.Varint).int32(message.permissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User_DiscordInfo$Type extends MessageType<User_DiscordInfo> {
    constructor() {
        super("proto.models.User.DiscordInfo", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "avatar_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User_DiscordInfo>): User_DiscordInfo {
        const message = { userId: "", username: "", avatarUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User_DiscordInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User_DiscordInfo): User_DiscordInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string avatar_url */ 3:
                    message.avatarUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User_DiscordInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string avatar_url = 3; */
        if (message.avatarUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.avatarUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User.DiscordInfo
 */
export const User_DiscordInfo = new User_DiscordInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User_Point$Type extends MessageType<User_Point> {
    constructor() {
        super("proto.models.User.Point", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<User_Point>): User_Point {
        const message = { x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User_Point>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User_Point): User_Point {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User_Point, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User.Point
 */
export const User_Point = new User_Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Match$Type extends MessageType<Match> {
    constructor() {
        super("proto.models.Match", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "associated_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leader", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "selected_map", kind: "message", T: () => Map }
        ]);
    }
    create(value?: PartialMessage<Match>): Match {
        const message = { guid: "", associatedUsers: [], leader: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Match>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Match): Match {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* repeated string associated_users */ 2:
                    message.associatedUsers.push(reader.string());
                    break;
                case /* string leader */ 3:
                    message.leader = reader.string();
                    break;
                case /* proto.models.Map selected_map */ 4:
                    message.selectedMap = Map.internalBinaryRead(reader, reader.uint32(), options, message.selectedMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Match, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* repeated string associated_users = 2; */
        for (let i = 0; i < message.associatedUsers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.associatedUsers[i]);
        /* string leader = 3; */
        if (message.leader !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leader);
        /* proto.models.Map selected_map = 4; */
        if (message.selectedMap)
            Map.internalBinaryWrite(message.selectedMap, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Match
 */
export const Match = new Match$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QualifierEvent$Type extends MessageType<QualifierEvent> {
    constructor() {
        super("proto.models.QualifierEvent", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "info_channel", kind: "message", T: () => Channel },
            { no: 5, name: "qualifier_maps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Map },
            { no: 6, name: "flags", kind: "enum", T: () => ["proto.models.QualifierEvent.EventSettings", QualifierEvent_EventSettings] },
            { no: 7, name: "sort", kind: "enum", T: () => ["proto.models.QualifierEvent.LeaderboardSort", QualifierEvent_LeaderboardSort] }
        ]);
    }
    create(value?: PartialMessage<QualifierEvent>): QualifierEvent {
        const message = { guid: "", name: "", image: new Uint8Array(0), qualifierMaps: [], flags: 0, sort: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QualifierEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QualifierEvent): QualifierEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bytes image */ 3:
                    message.image = reader.bytes();
                    break;
                case /* proto.discord.Channel info_channel */ 4:
                    message.infoChannel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.infoChannel);
                    break;
                case /* repeated proto.models.Map qualifier_maps */ 5:
                    message.qualifierMaps.push(Map.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* proto.models.QualifierEvent.EventSettings flags */ 6:
                    message.flags = reader.int32();
                    break;
                case /* proto.models.QualifierEvent.LeaderboardSort sort */ 7:
                    message.sort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QualifierEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bytes image = 3; */
        if (message.image.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.image);
        /* proto.discord.Channel info_channel = 4; */
        if (message.infoChannel)
            Channel.internalBinaryWrite(message.infoChannel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.Map qualifier_maps = 5; */
        for (let i = 0; i < message.qualifierMaps.length; i++)
            Map.internalBinaryWrite(message.qualifierMaps[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.QualifierEvent.EventSettings flags = 6; */
        if (message.flags !== 0)
            writer.tag(6, WireType.Varint).int32(message.flags);
        /* proto.models.QualifierEvent.LeaderboardSort sort = 7; */
        if (message.sort !== 0)
            writer.tag(7, WireType.Varint).int32(message.sort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.QualifierEvent
 */
export const QualifierEvent = new QualifierEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoreServer$Type extends MessageType<CoreServer> {
    constructor() {
        super("proto.models.CoreServer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "websocket_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CoreServer>): CoreServer {
        const message = { name: "", address: "", port: 0, websocketPort: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoreServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoreServer): CoreServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* int32 websocket_port */ 4:
                    message.websocketPort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoreServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* int32 websocket_port = 4; */
        if (message.websocketPort !== 0)
            writer.tag(4, WireType.Varint).int32(message.websocketPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.CoreServer
 */
export const CoreServer = new CoreServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament$Type extends MessageType<Tournament> {
    constructor() {
        super("proto.models.Tournament", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings", kind: "message", T: () => Tournament_TournamentSettings },
            { no: 3, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => User },
            { no: 4, name: "matches", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Match },
            { no: 5, name: "qualifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QualifierEvent },
            { no: 6, name: "server", kind: "message", T: () => CoreServer }
        ]);
    }
    create(value?: PartialMessage<Tournament>): Tournament {
        const message = { guid: "", users: [], matches: [], qualifiers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament): Tournament {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* proto.models.Tournament.TournamentSettings settings */ 2:
                    message.settings = Tournament_TournamentSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* repeated proto.models.User users */ 3:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.Match matches */ 4:
                    message.matches.push(Match.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.QualifierEvent qualifiers */ 5:
                    message.qualifiers.push(QualifierEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* proto.models.CoreServer server */ 6:
                    message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* proto.models.Tournament.TournamentSettings settings = 2; */
        if (message.settings)
            Tournament_TournamentSettings.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.User users = 3; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.Match matches = 4; */
        for (let i = 0; i < message.matches.length; i++)
            Match.internalBinaryWrite(message.matches[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.QualifierEvent qualifiers = 5; */
        for (let i = 0; i < message.qualifiers.length; i++)
            QualifierEvent.internalBinaryWrite(message.qualifiers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.CoreServer server = 6; */
        if (message.server)
            CoreServer.internalBinaryWrite(message.server, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament
 */
export const Tournament = new Tournament$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament_TournamentSettings$Type extends MessageType<Tournament_TournamentSettings> {
    constructor() {
        super("proto.models.Tournament.TournamentSettings", [
            { no: 1, name: "tournament_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tournament_image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "enable_teams", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "enable_pools", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "teams", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tournament_TournamentSettings_Team },
            { no: 6, name: "score_update_frequency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "banned_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pools", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tournament_TournamentSettings_Pool },
            { no: 9, name: "show_tournament_button", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "show_qualifier_button", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "allow_unauthorized_view", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Tournament_TournamentSettings>): Tournament_TournamentSettings {
        const message = { tournamentName: "", tournamentImage: new Uint8Array(0), enableTeams: false, enablePools: false, teams: [], scoreUpdateFrequency: 0, bannedMods: [], pools: [], showTournamentButton: false, showQualifierButton: false, allowUnauthorizedView: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament_TournamentSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament_TournamentSettings): Tournament_TournamentSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tournament_name */ 1:
                    message.tournamentName = reader.string();
                    break;
                case /* bytes tournament_image */ 2:
                    message.tournamentImage = reader.bytes();
                    break;
                case /* bool enable_teams */ 3:
                    message.enableTeams = reader.bool();
                    break;
                case /* bool enable_pools */ 4:
                    message.enablePools = reader.bool();
                    break;
                case /* repeated proto.models.Tournament.TournamentSettings.Team teams */ 5:
                    message.teams.push(Tournament_TournamentSettings_Team.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 score_update_frequency */ 6:
                    message.scoreUpdateFrequency = reader.int32();
                    break;
                case /* repeated string banned_mods */ 7:
                    message.bannedMods.push(reader.string());
                    break;
                case /* repeated proto.models.Tournament.TournamentSettings.Pool pools */ 8:
                    message.pools.push(Tournament_TournamentSettings_Pool.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool show_tournament_button */ 9:
                    message.showTournamentButton = reader.bool();
                    break;
                case /* bool show_qualifier_button */ 10:
                    message.showQualifierButton = reader.bool();
                    break;
                case /* bool allow_unauthorized_view */ 11:
                    message.allowUnauthorizedView = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament_TournamentSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tournament_name = 1; */
        if (message.tournamentName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tournamentName);
        /* bytes tournament_image = 2; */
        if (message.tournamentImage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.tournamentImage);
        /* bool enable_teams = 3; */
        if (message.enableTeams !== false)
            writer.tag(3, WireType.Varint).bool(message.enableTeams);
        /* bool enable_pools = 4; */
        if (message.enablePools !== false)
            writer.tag(4, WireType.Varint).bool(message.enablePools);
        /* repeated proto.models.Tournament.TournamentSettings.Team teams = 5; */
        for (let i = 0; i < message.teams.length; i++)
            Tournament_TournamentSettings_Team.internalBinaryWrite(message.teams[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 score_update_frequency = 6; */
        if (message.scoreUpdateFrequency !== 0)
            writer.tag(6, WireType.Varint).int32(message.scoreUpdateFrequency);
        /* repeated string banned_mods = 7; */
        for (let i = 0; i < message.bannedMods.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.bannedMods[i]);
        /* repeated proto.models.Tournament.TournamentSettings.Pool pools = 8; */
        for (let i = 0; i < message.pools.length; i++)
            Tournament_TournamentSettings_Pool.internalBinaryWrite(message.pools[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool show_tournament_button = 9; */
        if (message.showTournamentButton !== false)
            writer.tag(9, WireType.Varint).bool(message.showTournamentButton);
        /* bool show_qualifier_button = 10; */
        if (message.showQualifierButton !== false)
            writer.tag(10, WireType.Varint).bool(message.showQualifierButton);
        /* bool allow_unauthorized_view = 11; */
        if (message.allowUnauthorizedView !== false)
            writer.tag(11, WireType.Varint).bool(message.allowUnauthorizedView);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament.TournamentSettings
 */
export const Tournament_TournamentSettings = new Tournament_TournamentSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament_TournamentSettings_Pool$Type extends MessageType<Tournament_TournamentSettings_Pool> {
    constructor() {
        super("proto.models.Tournament.TournamentSettings.Pool", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "maps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Map }
        ]);
    }
    create(value?: PartialMessage<Tournament_TournamentSettings_Pool>): Tournament_TournamentSettings_Pool {
        const message = { guid: "", name: "", image: new Uint8Array(0), maps: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament_TournamentSettings_Pool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament_TournamentSettings_Pool): Tournament_TournamentSettings_Pool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bytes image */ 3:
                    message.image = reader.bytes();
                    break;
                case /* repeated proto.models.Map maps */ 4:
                    message.maps.push(Map.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament_TournamentSettings_Pool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bytes image = 3; */
        if (message.image.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.image);
        /* repeated proto.models.Map maps = 4; */
        for (let i = 0; i < message.maps.length; i++)
            Map.internalBinaryWrite(message.maps[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament.TournamentSettings.Pool
 */
export const Tournament_TournamentSettings_Pool = new Tournament_TournamentSettings_Pool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament_TournamentSettings_Team$Type extends MessageType<Tournament_TournamentSettings_Team> {
    constructor() {
        super("proto.models.Tournament.TournamentSettings.Team", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Tournament_TournamentSettings_Team>): Tournament_TournamentSettings_Team {
        const message = { guid: "", name: "", image: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament_TournamentSettings_Team>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament_TournamentSettings_Team): Tournament_TournamentSettings_Team {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bytes image */ 3:
                    message.image = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament_TournamentSettings_Team, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bytes image = 3; */
        if (message.image.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.image);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament.TournamentSettings.Team
 */
export const Tournament_TournamentSettings_Team = new Tournament_TournamentSettings_Team$Type();
// @generated message type with reflection information, may provide speed optimized methods
class State$Type extends MessageType<State> {
    constructor() {
        super("proto.models.State", [
            { no: 1, name: "tournaments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tournament },
            { no: 2, name: "known_servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoreServer }
        ]);
    }
    create(value?: PartialMessage<State>): State {
        const message = { tournaments: [], knownServers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: State): State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.models.Tournament tournaments */ 1:
                    message.tournaments.push(Tournament.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.CoreServer known_servers */ 2:
                    message.knownServers.push(CoreServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.models.Tournament tournaments = 1; */
        for (let i = 0; i < message.tournaments.length; i++)
            Tournament.internalBinaryWrite(message.tournaments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.CoreServer known_servers = 2; */
        for (let i = 0; i < message.knownServers.length; i++)
            CoreServer.internalBinaryWrite(message.knownServers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.State
 */
export const State = new State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModalOption$Type extends MessageType<ModalOption> {
    constructor() {
        super("proto.models.ModalOption", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModalOption>): ModalOption {
        const message = { label: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModalOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModalOption): ModalOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModalOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.ModalOption
 */
export const ModalOption = new ModalOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardEntry$Type extends MessageType<LeaderboardEntry> {
    constructor() {
        super("proto.models.LeaderboardEntry", [
            { no: 1, name: "event_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "multiplied_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "modified_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "max_possible_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "accuracy", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "notes_missed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "bad_cuts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "good_cuts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "max_combo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "full_combo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_placeholder", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardEntry>): LeaderboardEntry {
        const message = { eventId: "", mapId: "", platformId: "", username: "", multipliedScore: 0, modifiedScore: 0, maxPossibleScore: 0, accuracy: 0, notesMissed: 0, badCuts: 0, goodCuts: 0, maxCombo: 0, fullCombo: false, isPlaceholder: false, color: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LeaderboardEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardEntry): LeaderboardEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event_id */ 1:
                    message.eventId = reader.string();
                    break;
                case /* string map_id */ 2:
                    message.mapId = reader.string();
                    break;
                case /* string platform_id */ 3:
                    message.platformId = reader.string();
                    break;
                case /* string username */ 4:
                    message.username = reader.string();
                    break;
                case /* int32 multiplied_score */ 5:
                    message.multipliedScore = reader.int32();
                    break;
                case /* int32 modified_score */ 6:
                    message.modifiedScore = reader.int32();
                    break;
                case /* int32 max_possible_score */ 7:
                    message.maxPossibleScore = reader.int32();
                    break;
                case /* double accuracy */ 8:
                    message.accuracy = reader.double();
                    break;
                case /* int32 notes_missed */ 9:
                    message.notesMissed = reader.int32();
                    break;
                case /* int32 bad_cuts */ 10:
                    message.badCuts = reader.int32();
                    break;
                case /* int32 good_cuts */ 11:
                    message.goodCuts = reader.int32();
                    break;
                case /* int32 max_combo */ 12:
                    message.maxCombo = reader.int32();
                    break;
                case /* bool full_combo */ 13:
                    message.fullCombo = reader.bool();
                    break;
                case /* bool is_placeholder */ 14:
                    message.isPlaceholder = reader.bool();
                    break;
                case /* string color */ 15:
                    message.color = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_id = 1; */
        if (message.eventId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.eventId);
        /* string map_id = 2; */
        if (message.mapId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mapId);
        /* string platform_id = 3; */
        if (message.platformId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.platformId);
        /* string username = 4; */
        if (message.username !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.username);
        /* int32 multiplied_score = 5; */
        if (message.multipliedScore !== 0)
            writer.tag(5, WireType.Varint).int32(message.multipliedScore);
        /* int32 modified_score = 6; */
        if (message.modifiedScore !== 0)
            writer.tag(6, WireType.Varint).int32(message.modifiedScore);
        /* int32 max_possible_score = 7; */
        if (message.maxPossibleScore !== 0)
            writer.tag(7, WireType.Varint).int32(message.maxPossibleScore);
        /* double accuracy = 8; */
        if (message.accuracy !== 0)
            writer.tag(8, WireType.Bit64).double(message.accuracy);
        /* int32 notes_missed = 9; */
        if (message.notesMissed !== 0)
            writer.tag(9, WireType.Varint).int32(message.notesMissed);
        /* int32 bad_cuts = 10; */
        if (message.badCuts !== 0)
            writer.tag(10, WireType.Varint).int32(message.badCuts);
        /* int32 good_cuts = 11; */
        if (message.goodCuts !== 0)
            writer.tag(11, WireType.Varint).int32(message.goodCuts);
        /* int32 max_combo = 12; */
        if (message.maxCombo !== 0)
            writer.tag(12, WireType.Varint).int32(message.maxCombo);
        /* bool full_combo = 13; */
        if (message.fullCombo !== false)
            writer.tag(13, WireType.Varint).bool(message.fullCombo);
        /* bool is_placeholder = 14; */
        if (message.isPlaceholder !== false)
            writer.tag(14, WireType.Varint).bool(message.isPlaceholder);
        /* string color = 15; */
        if (message.color !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.color);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.LeaderboardEntry
 */
export const LeaderboardEntry = new LeaderboardEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RealtimeScore$Type extends MessageType<RealtimeScore> {
    constructor() {
        super("proto.models.RealtimeScore", [
            { no: 1, name: "user_guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "score_with_modifiers", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "max_score_with_modifiers", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "combo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "player_health", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "accuracy", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "song_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "notes_missed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "bad_cuts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "bomb_hits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "wall_hits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "max_combo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "left_hand", kind: "message", T: () => ScoreTrackerHand },
            { no: 16, name: "right_hand", kind: "message", T: () => ScoreTrackerHand }
        ]);
    }
    create(value?: PartialMessage<RealtimeScore>): RealtimeScore {
        const message = { userGuid: "", score: 0, scoreWithModifiers: 0, maxScore: 0, maxScoreWithModifiers: 0, combo: 0, playerHealth: 0, accuracy: 0, songPosition: 0, notesMissed: 0, badCuts: 0, bombHits: 0, wallHits: 0, maxCombo: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RealtimeScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RealtimeScore): RealtimeScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_guid */ 1:
                    message.userGuid = reader.string();
                    break;
                case /* int32 score */ 2:
                    message.score = reader.int32();
                    break;
                case /* int32 score_with_modifiers */ 3:
                    message.scoreWithModifiers = reader.int32();
                    break;
                case /* int32 max_score */ 4:
                    message.maxScore = reader.int32();
                    break;
                case /* int32 max_score_with_modifiers */ 5:
                    message.maxScoreWithModifiers = reader.int32();
                    break;
                case /* int32 combo */ 6:
                    message.combo = reader.int32();
                    break;
                case /* float player_health */ 7:
                    message.playerHealth = reader.float();
                    break;
                case /* float accuracy */ 8:
                    message.accuracy = reader.float();
                    break;
                case /* float song_position */ 9:
                    message.songPosition = reader.float();
                    break;
                case /* int32 notes_missed */ 10:
                    message.notesMissed = reader.int32();
                    break;
                case /* int32 bad_cuts */ 11:
                    message.badCuts = reader.int32();
                    break;
                case /* int32 bomb_hits */ 12:
                    message.bombHits = reader.int32();
                    break;
                case /* int32 wall_hits */ 13:
                    message.wallHits = reader.int32();
                    break;
                case /* int32 max_combo */ 14:
                    message.maxCombo = reader.int32();
                    break;
                case /* proto.models.ScoreTrackerHand left_hand */ 15:
                    message.leftHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.leftHand);
                    break;
                case /* proto.models.ScoreTrackerHand right_hand */ 16:
                    message.rightHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.rightHand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RealtimeScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_guid = 1; */
        if (message.userGuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userGuid);
        /* int32 score = 2; */
        if (message.score !== 0)
            writer.tag(2, WireType.Varint).int32(message.score);
        /* int32 score_with_modifiers = 3; */
        if (message.scoreWithModifiers !== 0)
            writer.tag(3, WireType.Varint).int32(message.scoreWithModifiers);
        /* int32 max_score = 4; */
        if (message.maxScore !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxScore);
        /* int32 max_score_with_modifiers = 5; */
        if (message.maxScoreWithModifiers !== 0)
            writer.tag(5, WireType.Varint).int32(message.maxScoreWithModifiers);
        /* int32 combo = 6; */
        if (message.combo !== 0)
            writer.tag(6, WireType.Varint).int32(message.combo);
        /* float player_health = 7; */
        if (message.playerHealth !== 0)
            writer.tag(7, WireType.Bit32).float(message.playerHealth);
        /* float accuracy = 8; */
        if (message.accuracy !== 0)
            writer.tag(8, WireType.Bit32).float(message.accuracy);
        /* float song_position = 9; */
        if (message.songPosition !== 0)
            writer.tag(9, WireType.Bit32).float(message.songPosition);
        /* int32 notes_missed = 10; */
        if (message.notesMissed !== 0)
            writer.tag(10, WireType.Varint).int32(message.notesMissed);
        /* int32 bad_cuts = 11; */
        if (message.badCuts !== 0)
            writer.tag(11, WireType.Varint).int32(message.badCuts);
        /* int32 bomb_hits = 12; */
        if (message.bombHits !== 0)
            writer.tag(12, WireType.Varint).int32(message.bombHits);
        /* int32 wall_hits = 13; */
        if (message.wallHits !== 0)
            writer.tag(13, WireType.Varint).int32(message.wallHits);
        /* int32 max_combo = 14; */
        if (message.maxCombo !== 0)
            writer.tag(14, WireType.Varint).int32(message.maxCombo);
        /* proto.models.ScoreTrackerHand left_hand = 15; */
        if (message.leftHand)
            ScoreTrackerHand.internalBinaryWrite(message.leftHand, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.ScoreTrackerHand right_hand = 16; */
        if (message.rightHand)
            ScoreTrackerHand.internalBinaryWrite(message.rightHand, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.RealtimeScore
 */
export const RealtimeScore = new RealtimeScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoreTrackerHand$Type extends MessageType<ScoreTrackerHand> {
    constructor() {
        super("proto.models.ScoreTrackerHand", [
            { no: 1, name: "hit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "miss", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bad_cut", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "avg_cut", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ScoreTrackerHand>): ScoreTrackerHand {
        const message = { hit: 0, miss: 0, badCut: 0, avgCut: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScoreTrackerHand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScoreTrackerHand): ScoreTrackerHand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 hit */ 1:
                    message.hit = reader.int32();
                    break;
                case /* int32 miss */ 2:
                    message.miss = reader.int32();
                    break;
                case /* int32 bad_cut */ 3:
                    message.badCut = reader.int32();
                    break;
                case /* repeated float avg_cut */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avgCut.push(reader.float());
                    else
                        message.avgCut.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScoreTrackerHand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 hit = 1; */
        if (message.hit !== 0)
            writer.tag(1, WireType.Varint).int32(message.hit);
        /* int32 miss = 2; */
        if (message.miss !== 0)
            writer.tag(2, WireType.Varint).int32(message.miss);
        /* int32 bad_cut = 3; */
        if (message.badCut !== 0)
            writer.tag(3, WireType.Varint).int32(message.badCut);
        /* repeated float avg_cut = 4; */
        if (message.avgCut.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avgCut.length; i++)
                writer.float(message.avgCut[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.ScoreTrackerHand
 */
export const ScoreTrackerHand = new ScoreTrackerHand$Type();
